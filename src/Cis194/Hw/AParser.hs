module Cis194.Hw.AParser where

import           Control.Applicative
import           Control.Monad
import           Data.Char

newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }

char :: Char -> Parser Char
char c = satisfy (== c)

satisfy :: (Char -> Bool) -> Parser Char
satisfy p = Parser f
  where
    f [] = Nothing
    f (x:xs)
        | p x       = Just (x, xs)
        | otherwise = Nothing

posInt :: Parser Integer
posInt = Parser f
  where
    f xs
      | null ns   = Nothing
      | otherwise = Just (read ns, rest)
      where (ns, rest) = span isDigit xs

------------------------------------------------------------
-- Your code goes below here
------------------------------------------------------------

first :: (a -> b) -> (a,c) -> (b,c)
first f (a, c) = (f a , c)

-- Parsers act on one symbol at a time (in this case the symbols are simply characters)
-- Because of this we can combine multiple parsers into a larger statement with
-- Applicatives. However, we also need to lift other functions into the context
-- of Parser in order to combine the output of parsers in interesting ways.
-- For instance we'll be able to say things like this:
--   abParser = (,) <$> char 'a' <*> char 'b'
-- `char c` returns us a parser for the given character; `(,)` is the function
-- to create pairs. The `(,) <$> char 'a'` lifts (,) into the context of the
-- parser and partially applies it to the runParser function generated by char 'a'.
-- For instance if we have Parser f then (,) <$> Parser f we would need
-- something like Parser (f . (,)).
-- We know that f :: String -> Maybe (a, String) so in order to make these
-- types work out we need an implementation of fmap that lifts the given
-- function not just into the context of Parser, but into the context of Maybe.
-- We can then apply that function to the first argument in the pair (which is
-- the return value.).
--
-- TL;DR - After we call (,) <$> char 'a' we should end up with something like
-- this:
--     Parser $ String -> Maybe ((f a :: b), String)
--
-- We can achieve this by using partial function application with first and f,
-- composing that with the parser function, and using fmap to lift this composed
-- function into the context of Maybe.
instance Functor Parser where
  fmap f (Parser p) = Parser $ (first f <$>) . p

instance Applicative Parser where
  pure x    = Parser (\y -> Just (x, y))
  p1 <*> p2 = Parser p
    where
      p s = case runParser p1 s of
        Just (f, ss) -> runParser (f <$> p2) ss
        Nothing      -> Nothing

abParser :: Parser (Char, Char)
abParser = (,) <$> char 'a' <*> char 'b'

abParser_ :: Parser ()
abParser_ = (\_ _ -> ()) <$> char 'a' <*> char 'b'

intPair :: Parser [Integer]
intPair = (\x _ y -> [x, y]) <$> posInt <*> char ' ' <*> posInt

instance Alternative Parser where
  empty = Parser (const Nothing)
  p1 <|> p2 = Parser p
    where
      p s = runParser p1 s <|> runParser p2 s

intOrUppercase :: Parser ()
intOrUppercase = void posInt <|> void (satisfy isUpper)
